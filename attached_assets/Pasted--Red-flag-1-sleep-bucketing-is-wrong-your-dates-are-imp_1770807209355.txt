ğŸš¨ Red flag #1: sleep bucketing is wrong (your dates are impossible)

You have:
	â€¢	2026-02-10 sleep_minutes = 101 â€œbucketed to 2026-02-10â€
	â€¢	Source: UserSleeps_2025-11-27.csv (!!!)
	â€¢	2026-02-11 sleep_minutes = 104 from sleep-2026-01-25.json (!!!)

Two separate impossibilities:
	1.	A file named 2025-11-27 contributing to 2026-02-10 strongly suggests your parser is using the file name as a â€œmonth shard labelâ€ but reading row timestamps wrong (or mixing UTC/local date conversion, or parsing â€œtimestampâ€ as month/day swapped, etc.).
	2.	sleep_minutes ~ 101 / 104 is not â€œsleep minutes.â€ That looks like a subset (REM? deep? awake? naps?) or a single segment, not total sleep. If it is total sleep, youâ€™re severely undercounting.

What to tell Replit to do next (copy/paste)

Fix sleep correctness first. Add a sleep import invariant check + diagnostics output:
	â€¢	For each imported sleep row, log: raw start, raw end, minutes_asleep, date bucket chosen, timezone used, source file path, and whether value is segment vs daily total.
	â€¢	Assert: sleep_minutes daily total should usually be 240â€“600 for most nights. If <180 or >900, mark as suspicious and store a conflict record.
	â€¢	Confirm the bucketing rule is: bucket to wake-date in LOCAL time, not UTC day.
	â€¢	Confirm CSV parsing is not using filename date to compute row date, only the rowâ€™s timestamp/end time.

If you want one â€œgold standardâ€ rule: sleep day = local date of sleep end (wake time).

â¸»

ğŸš¨ Red flag #2: recompute range logic is wrong for imports

You wrote:

recomputeReadinessRange(minDay)
start = targetDate - 7 days
end = targetDate + 1 day
â€¦persistâ€¦

If minDay is â€œearliest affected date,â€ then for a Takeout import that spans years, recomputing only 8â€“9 days around the earliest day is not enough. You need to recompute either:
	â€¢	the entire affected span (minDay â€¦ maxDay) with window padding, or
	â€¢	recompute only recent analysis window (good), but then you must recompute that window, not minDay.

What to tell Replit (copy/paste)

Update recompute after import:
	â€¢	Track both minDay and maxDay affected during import.
	â€¢	Recompute readiness for:
recomputeRange( max(analysis_start_date - 28d, minDay - 28d)  â€¦  maxDay + 1d )
(28d padding because you compare 7d vs 28d)
	â€¢	Or simplest: recompute only the analysis window each import:
recomputeRange(analysis_start_date - 28d â€¦ today).

Right now, the import could be correct, but readiness stays stale except around one boundary.

â¸»

Important: your â€œscore=27 floorâ€ is expected given gating â€” but you should label it better

Because you only have 2 days of data, the system cannot form 7d/28d deltas. Thatâ€™s fine. But showing:
	â€¢	Sleep: +0% vs baseline
	â€¢	RHR: +0 bpm vs baseline
	â€¢	Proxy: +0% vs baseline

â€¦creates a false impression of â€œstable.â€ Itâ€™s actually â€œinsufficient.â€

Quick UI truth fix (copy/paste)

If gate < 7 days:
	â€¢	show deltas as â€œâ€”â€ not â€œ+0â€
	â€¢	show a banner: â€œNot enough data to compute deltas (need 7d / 28d).â€
	â€¢	readiness score should either be hidden or explicitly labeled â€œprovisional floor.â€

â¸»

Your question about schedule adherence (bedtime/wake vs actual)

Youâ€™re 100% right: manual bedtime/wake is valuable, even if Fitbit gives minutes.

Treat them as two separate concepts:
	â€¢	Planned / self-reported: sleep_plan_bedtime, sleep_plan_wake, maybe â€œtossed/insomnia minutesâ€
	â€¢	Observed (Fitbit): sleep_end_local, sleep_start_local (derived), sleep_minutes

Then compute adherence features:
	â€¢	wake_deviation_min = actual_wake - planned_wake
	â€¢	bed_deviation_min = actual_bed - planned_bed (if you store actual start)
	â€¢	sleep_efficiency_proxy = sleep_minutes / time_in_bed_minutes (if you have both)

Readiness can keep using sleep_minutes for now, but your â€œplan adherenceâ€ layer will get much smarter with these.